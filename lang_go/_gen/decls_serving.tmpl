
import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strconv"
	"sync"
)

{{ $main := . -}}

type Server struct {
	sync.Mutex // sync writes to stdout
	stdout *bufio.Writer
	waiters map[string]func()

	Lang struct {
		CompletionTriggerChars []string
		SignatureTriggerChars []string
		Commands []string
	}

	// Initialized is for informational purposes only, to the importer who shall not set or mutate them.
	// Its fields are set automatically at the appropriate initialization lifecycle instant.
	Initialized struct {
		Client *InitializeParams
		Server *InitializeResult
	}

	{{ range $main.Decls.Extras -}}
	{{- $msg := . -}}
	{{- if and $msg.IsClientToServer (not $msg.IsInit) -}}
	{{- range $msg.DocLines }}
	// {{ . }}
	{{- end }}
	On_{{ $msg.MethodNameSafe }} func(params *{{ $msg.UnaryParamsTypeName }}) (any, error)
	{{ end -}}
	{{- end -}}
}

{{- range $main.Decls.Extras -}}
{{- $msg := . }}
{{- if $msg.IsServerToClient }}
{{- range $msg.DocLines }}
// {{ . }}
{{- end }}
func (it *Server) Send_{{ $msg.MethodNameSafe }} (params *{{ $msg.UnaryParamsTypeName }}{{if $msg.IsReq}}, onResp func(*{{- if $msg.IsReq -}}{{- $main.DoType $msg.ResultType -}}{{- end -}}){{end}}) {
}
{{- end }}
{{- end }}

func (it *Server) handleIncoming(jsonRpcMsg []byte) *jsonRpcError {
	raw := map[string]any{}
	if err := json.Unmarshal(jsonRpcMsg, &raw); err != nil {
		return &jsonRpcError{ Code: -32700, Message: err.Error() }
	}
	msg_id, msg_method, msg_err_code :=raw["id"], raw["method"], raw["code"]

	if msg_err_code != nil { // received an error Response
		println(string(jsonRpcMsg)) // goes to stderr
		return nil
	}

	switch msg_method, _ := msg_method.(string); msg_method {
	case "":  // msg is an incoming Response
        msg_id := fmt.Sprintf("%v", msg_id)
		handler := it.waiters[msg_id]
		delete(it.waiters, msg_id)
		go handler()
	{{- range $main.Decls.Extras -}}
	{{- $msg := . }}
	{{- if and $msg.IsClientToServer (not $msg.IsInit) }}
	case "{{$msg.Method}}":
		serverHandleIncoming(it, it.On_{{ $msg.MethodNameSafe }}, msg_method, msg_id, raw["params"])
	{{- end }}
	{{- end }}
	case "initialize":
		serverHandleIncoming(it, func(params *InitializeParams) (any, error) {
			init := &it.Initialized
			init.Client = params
			init.Server = &InitializeResult{
				ServerInfo: &struct {
					Name    string
					Version *String
				}{Name: os.Args[0]},
			}
			caps := &init.Server.Capabilities
			caps.TextDocumentSync.TextDocumentSyncOptions = &TextDocumentSyncOptions{
				OpenClose: ptr(Boolean(it.On_textDocument_didClose != nil || it.On_textDocument_didOpen != nil)),
				Change: iIf(it.On_textDocument_didChange == nil, TextDocumentSyncKindNone, TextDocumentSyncKindFull),
			}
			if it.On_textDocument_completion != nil {
				caps.CompletionProvider = &CompletionOptions{ TriggerCharacters: it.Lang.CompletionTriggerChars }
			}
			caps.HoverProvider.Boolean = ptr(Boolean(it.On_textDocument_hover != nil))
			if it.On_textDocument_signatureHelp != nil {
				caps.SignatureHelpProvider = &SignatureHelpOptions{ TriggerCharacters: it.Lang.SignatureTriggerChars }
			}
			caps.DeclarationProvider.Boolean = ptr(Boolean(it.On_textDocument_declaration != nil))
			caps.DefinitionProvider.Boolean = ptr(Boolean(it.On_textDocument_definition != nil))
			caps.TypeDefinitionProvider.Boolean = ptr(Boolean(it.On_textDocument_typeDefinition != nil))
			caps.ImplementationProvider.Boolean = ptr(Boolean(it.On_textDocument_implementation != nil))
			caps.ReferencesProvider.Boolean = ptr(Boolean(it.On_textDocument_references != nil))
			caps.DocumentHighlightProvider.Boolean = ptr(Boolean(it.On_textDocument_documentHighlight != nil))
			caps.DocumentSymbolProvider.Boolean = ptr(Boolean(it.On_textDocument_documentSymbol != nil))
			caps.CodeActionProvider.Boolean = ptr(Boolean(it.On_textDocument_codeAction != nil))
			if it.On_textDocument_codeLens != nil {
				caps.CodeLensProvider = &CodeLensOptions{}
			}
			caps.DocumentFormattingProvider.Boolean = ptr(Boolean(it.On_textDocument_formatting != nil))
			caps.DocumentRangeFormattingProvider.Boolean = ptr(Boolean(it.On_textDocument_rangeFormatting != nil))
			caps.RenameProvider.RenameOptions = iIf(it.On_textDocument_rename == nil, nil, &RenameOptions{
				PrepareProvider: ptr(Boolean(it.On_textDocument_prepareRename != nil)),
			})
			if it.On_workspace_executeCommand != nil {
				caps.ExecuteCommandProvider = &ExecuteCommandOptions{Commands: it.Lang.Commands}
			}
			caps.SelectionRangeProvider.Boolean = ptr(Boolean(it.On_textDocument_selectionRange != nil))
			caps.CallHierarchyProvider.Boolean = ptr(Boolean(it.On_textDocument_prepareCallHierarchy != nil && it.On_callHierarchy_incomingCalls != nil && it.On_callHierarchy_outgoingCalls != nil))
			caps.TypeHierarchyProvider.Boolean = ptr(Boolean(it.On_textDocument_prepareTypeHierarchy != nil && it.On_typeHierarchy_subtypes != nil && it.On_typeHierarchy_supertypes != nil))
			caps.InlineValueProvider.Boolean = ptr(Boolean(it.On_textDocument_inlineValue != nil))
			caps.InlayHintProvider.Boolean=ptr(Boolean(it.On_textDocument_inlayHint!=nil))
			caps.WorkspaceSymbolProvider.Boolean = ptr(Boolean(it.On_workspace_symbol != nil))
			caps.Workspace = &struct {
				WorkspaceFolders *WorkspaceFoldersServerCapabilities
				FileOperations   *FileOperationOptions
			}{
				WorkspaceFolders: &WorkspaceFoldersServerCapabilities{
					Supported: ptr(Boolean(it.On_workspace_didChangeWorkspaceFolders != nil)),
					ChangeNotifications: struct {
						String  *String
						Boolean *Boolean
					}{
						Boolean: ptr(Boolean(it.On_workspace_didChangeWorkspaceFolders != nil)),
					},
				},
			}

			return init.Server, nil
		}, msg_method, msg_id, raw["params"])
	default: // msg is an incoming Request or Notification
		return &jsonRpcError{ Code: -32601, Message: "unknown method: " + msg_method}
	}

	return nil
}

func ptr[T any](value T) *T { return &value }

func iIf[T any](chk bool, ifTrue T, ifFalse T) T {
	if chk {
		return ifTrue
	}
	return ifFalse
}

func serverHandleIncoming[T any] (it *Server, handler func (*T) (any, error), msgMethodName string, msgIdMaybe any, msgParams any) {
	var req_id string
	if msgIdMaybe != nil {
		req_id = fmt.Sprintf("%v", msgIdMaybe)
	}
	if handler == nil {
		if req_id != "" {
			it.sendErrMsg(errors.New("unimplemented: " + msgMethodName))
		}
		return
	}
	var params T
	if msgParams != nil {
		json_bytes, _ := json.Marshal(msgParams)
		if err := json.Unmarshal(json_bytes, &params); err != nil {
			it.sendErrMsg(&jsonRpcError{ Code: -32602, Message: err.Error() })
			return
		}
	}
	go func(params *T) {
		if msgParams == nil {
			params = nil
		}
		result, err := handler(params)
		resp := map[string]any {
			"result": result,
			"id": req_id,
		}
		if err != nil {
			if msgIdMaybe != nil {
				resp["error"] = &jsonRpcError{ Code: -32603, Message: fmt.Sprintf("%v", err) }
			}else {
				it.sendErrMsg(err)
				return
			}
		}
		if msgIdMaybe != nil {
			it.sendMsg(resp)
		}
	}(&params)
}

func (it *Server) sendErrMsg(err any) {
	if err == nil {
		return
	}
	var json_rpc_err_msg *jsonRpcError
	if json_rpc_err_msg, _ = err.(*jsonRpcError); json_rpc_err_msg == nil {
		json_rpc_err_msg = &jsonRpcError{ Code: -32603, Message: fmt.Sprintf("%v", err) }
	}
	it.sendMsg(json_rpc_err_msg)
}

func (it *Server) sendMsg(jsonable any) {
	err_json,_ := json.Marshal(jsonable)
	it.Lock()
	defer it.Unlock()
	_, _ = it.stdout.WriteString("Content-Length: ")
	_, _ = it.stdout.WriteString(strconv.Itoa(len(err_json)))
	_, _ = it.stdout.WriteString("\r\n\r\n")
	_, _ = it.stdout.Write(err_json)
}

// ServeForever keeps reading and handling LSP JSON-RPC messages incoming over `os.Stdin`
// until reading from `os.Stdin` fails, then returns that IO read error.
func (it *Server) ServeForever() error {
	const buf_cap = 1024 * 1024

	it.stdout = bufio.NewWriterSize(os.Stdout, buf_cap)
	it.waiters =  map[string]func(){}

	stdin := bufio.NewScanner(os.Stdin)
	stdin.Buffer(make([]byte, buf_cap), buf_cap)
	stdin.Split(func(data []byte, ateof bool) (advance int, token []byte, err error) {
		if i_cl1 := bytes.Index(data, []byte("Content-Length: ")); i_cl1 >= 0 {
			datafromclen := data[i_cl1+16:]
			if i_cl2 := bytes.IndexAny(datafromclen, "\r\n"); i_cl2 > 0 {
				if clen, e := strconv.Atoi(string(datafromclen[:i_cl2])); e != nil {
					err = e
				} else if i_js1 := bytes.Index(datafromclen, []byte("{\"")); i_js1 > i_cl2 {
					if i_js2 := i_js1 + clen; len(datafromclen) >= i_js2 {
						advance = i_cl1 + 16 + i_js2
						token = datafromclen[i_js1:i_js2]
					}
				}
			}
		}
		return
	})

	{ // users shouldn't have to set up no-op handlers for these routine teardown lifecycle messages:
		old_shutdown, old_exit, old_initialized := it.On_shutdown, it.On_exit, it.On_initialized
		it.On_shutdown = func(params *Void) (any, error) {
			if old_shutdown != nil {
				return old_shutdown(params)
			}
			return nil, nil
		}
		it.On_exit = func(params *Void) (any, error) {
			if old_exit != nil {
				return old_exit(params)
			}
			os.Exit(0)
			return nil, nil
		}
		it.On_initialized = func(params *InitializedParams) (any, error) {
			if it.On_workspace_didChangeWatchedFiles != nil {
				go it.Send_client_registerCapability(&RegistrationParams{
					Registrations: []Registration{
						{Method: "workspace/didChangeWatchedFiles", Id: "workspace/didChangeWatchedFiles",
							RegisterOptions: DidChangeWatchedFilesRegistrationOptions{Watchers: []FileSystemWatcher{
								{Kind: WatchKindChange | WatchKindCreate | WatchKindDelete,
									GlobPattern: GlobPattern{Pattern: ptr(String("**/*"))}}}}},
					},
				}, func(*Void) {})
			}
			if old_initialized != nil {
				return old_initialized(params)
			}
			return nil, nil
		}
	}

	for stdin.Scan() {
		err := it.handleIncoming(stdin.Bytes())
		if err != nil {
			it.sendErrMsg(err)
		}
	}
	return stdin.Err()
}
